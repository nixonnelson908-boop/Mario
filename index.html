<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mini 3D Coin Game</title>
  <style>
    html, body { margin:0; padding:0; overflow:hidden; background:#0b1020; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #hud {
      position: fixed; left: 12px; top: 12px; color: white;
      padding: 10px 12px; border-radius: 12px;
      background: rgba(0,0,0,0.35); backdrop-filter: blur(6px);
      user-select: none; pointer-events: none;
      font-weight: 700;
    }
    #hud small { display:block; opacity:.75; font-weight:600; margin-top:4px; }
    #menu {
      position: fixed; inset: 0; display: flex; align-items: center; justify-content: center;
      background: radial-gradient(circle at 50% 40%, rgba(40,140,255,.22), rgba(0,0,0,.85) 65%);
      color: white;
    }
    .panel {
      width: min(720px, 92vw);
      background: rgba(0,0,0,0.45);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 18px;
      padding: 18px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    }
    h1 { margin: 0 0 10px; font-size: 28px; letter-spacing: .2px; }
    p { margin: 8px 0; opacity: .9; line-height: 1.35; }
    .row { display:flex; gap:12px; flex-wrap: wrap; margin-top: 14px; }
    .swatch {
      width: 58px; height: 58px; border-radius: 14px; border: 2px solid rgba(255,255,255,0.16);
      display:flex; align-items:center; justify-content:center;
      cursor: pointer;
      position: relative;
      box-shadow: inset 0 0 0 2px rgba(0,0,0,0.25);
      transition: transform 0.08s ease;
    }
    .swatch:hover { transform: translateY(-1px); }
    .swatch.locked { opacity: .35; cursor: not-allowed; filter: grayscale(35%); }
    .swatch.selected { outline: 3px solid rgba(255,255,255,0.75); outline-offset: 3px; }
    .badge {
      position:absolute; bottom:-8px; right:-8px;
      background: rgba(0,0,0,0.65);
      border: 1px solid rgba(255,255,255,0.16);
      color: white; font-size: 11px; padding: 2px 6px; border-radius: 999px;
    }
    button {
      margin-top: 14px;
      appearance: none; border: 0; cursor: pointer;
      padding: 12px 16px; border-radius: 14px;
      background: rgba(255,255,255,0.92);
      color:#101424; font-weight: 900;
    }
    button:active { transform: translateY(1px); }
    #overlayMsg {
      position: fixed; inset: 0; display:none; align-items:center; justify-content:center;
      background: rgba(0,0,0,0.35);
      color:white; font-size: 56px; font-weight: 1000; letter-spacing: 1px;
      text-shadow: 0 10px 30px rgba(0,0,0,0.7);
      user-select:none;
    }
    #overlayMsg .sub { font-size: 16px; font-weight: 700; opacity: .85; margin-top: 12px; text-align:center; }
    #overlayMsg .wrap { display:flex; flex-direction: column; align-items:center; }
    canvas { display:block; }
  </style>
</head>
<body>
  <div id="hud" style="display:none">
    Coins: <span id="coinCount">0</span> / 100
    <small>WASD / Arrow keys to move • Space to jump • R reset • Mouse to rotate camera • Wheel zoom</small>
  </div>

  <div id="menu">
    <div class="panel">
      <h1>Mini 3D Coin Game</h1>
      <p>Pick your character color. Collect 100 coins to win. Each win unlocks a new color.</p>
      <p><b>Controls:</b> WASD/Arrows move, Space jumps, Mouse rotates camera, Wheel zooms, R resets.</p>
      <div class="row" id="colorRow"></div>
      <button id="startBtn">Start Game</button>
      <p style="margin-top:10px; opacity:.75">Tip: GitHub Pages runs this cleanly. Local file:// sometimes blocks CDN scripts.</p>
    </div>
  </div>

  <div id="overlayMsg">
    <div class="wrap">
      <div id="winText">You Win!</div>
      <div class="sub" id="winSub">Returning to menu…</div>
    </div>
  </div>

  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

  <script>
    // =========================
    // Persistent unlock system
    // =========================
    const STORAGE_KEY = "mini3d_coin_game_v1";
    const DEFAULT_STATE = { wins: 0, unlocked: 1, selectedColorIndex: 0 };

    const COLOR_PALETTE = [
      { name: "Red",    hex: 0xe74c3c },
      { name: "Green",  hex: 0x2ecc71 },
      { name: "Blue",   hex: 0x3498db },
      { name: "Yellow", hex: 0xf1c40f },
      { name: "Purple", hex: 0x9b59b6 },
      { name: "Orange", hex: 0xe67e22 },
      { name: "Cyan",   hex: 0x1abc9c },
      { name: "Pink",   hex: 0xff5ca8 },
      { name: "White",  hex: 0xf5f7ff },
      { name: "Black",  hex: 0x111318 },
    ];

    function loadState() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return { ...DEFAULT_STATE };
        return { ...DEFAULT_STATE, ...JSON.parse(raw) };
      } catch {
        return { ...DEFAULT_STATE };
      }
    }
    function saveState() { localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }
    let state = loadState();

    // =========================
    // UI (menu + unlocks)
    // =========================
    const menuEl = document.getElementById("menu");
    const colorRowEl = document.getElementById("colorRow");
    const startBtn = document.getElementById("startBtn");
    const hudEl = document.getElementById("hud");
    const coinCountEl = document.getElementById("coinCount");
    const overlayMsgEl = document.getElementById("overlayMsg");
    const winSubEl = document.getElementById("winSub");

    let selectedColorIndex = Math.min(state.selectedColorIndex, COLOR_PALETTE.length - 1);

    function renderColorPicker() {
      colorRowEl.innerHTML = "";
      const unlockedCount = Math.min(state.unlocked, COLOR_PALETTE.length);

      COLOR_PALETTE.forEach((c, idx) => {
        const div = document.createElement("div");
        div.className = "swatch" + (idx >= unlockedCount ? " locked" : "") + (idx === selectedColorIndex ? " selected" : "");
        div.style.background = `#${c.hex.toString(16).padStart(6, "0")}`;
        div.title = (idx < unlockedCount) ? c.name : `${c.name} (locked)`;

        const badge = document.createElement("div");
        badge.className = "badge";
        badge.textContent = (idx < unlockedCount) ? c.name : "LOCKED";
        div.appendChild(badge);

        if (idx < unlockedCount) {
          div.addEventListener("click", () => {
            selectedColorIndex = idx;
            state.selectedColorIndex = idx;
            saveState();
            renderColorPicker();
          });
        }
        colorRowEl.appendChild(div);
      });

      startBtn.textContent = `Start Game (Wins: ${state.wins})`;
    }
    renderColorPicker();

    // =========================
    // Three.js game setup
    // =========================
    let scene, camera, renderer;
    let player, playerVelocity;
    let ground;
    let coins = [];
    let coinCounter = 0;
    const COINS_TO_WIN = 100;

    // World settings
    const WORLD_SIZE = 180;
    const COIN_SPAWN_COUNT = 40;
    const COIN_RADIUS = 0.55;
    const PLAYER_RADIUS = 0.7;
    const PLAYER_HEIGHT = 1.6;

    // Movement
    const keys = new Set();
    const GRAVITY = -28;
    const MOVE_SPEED = 10;
    const JUMP_SPEED = 11.5;

    let running = false;
    let lastTime = 0;

    // =========================
    // Mouse camera controls (orbit)
    // =========================
    let camYaw = Math.PI;      // around Y
    let camPitch = 0.45;       // up/down
    let camDist = 12.0;        // zoom
    const CAM_MIN_DIST = 5.5;
    const CAM_MAX_DIST = 22.0;
    const CAM_MIN_PITCH = 0.12;
    const CAM_MAX_PITCH = 1.20;
    const MOUSE_SENS = 0.0032;

    let pointerLocked = false;

    function applyCamera() {
      // Spherical coordinates around player
      const x = Math.sin(camYaw) * Math.cos(camPitch) * camDist;
      const z = Math.cos(camYaw) * Math.cos(camPitch) * camDist;
      const y = Math.sin(camPitch) * camDist;

      const target = new THREE.Vector3(player.position.x, player.position.y + 1.1, player.position.z);
      camera.position.set(target.x + x, target.y + y, target.z + z);
      camera.lookAt(target);
    }

    function initThree() {
      scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x0b1020, 35, 220);

      camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 500);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      // Lights
      scene.add(new THREE.HemisphereLight(0xffffff, 0x223355, 0.8));
      const dir = new THREE.DirectionalLight(0xffffff, 1.0);
      dir.position.set(12, 18, 8);
      scene.add(dir);

      // Ground
      const groundGeo = new THREE.PlaneGeometry(WORLD_SIZE * 2, WORLD_SIZE * 2, 1, 1);
      const groundMat = new THREE.MeshStandardMaterial({ color: 0x1e2a44, roughness: 1.0, metalness: 0.0 });
      ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      scene.add(ground);

      const borderGeo = new THREE.RingGeometry(WORLD_SIZE - 1, WORLD_SIZE + 1, 64);
      const borderMat = new THREE.MeshBasicMaterial({ color: 0x223a66, side: THREE.DoubleSide, transparent:true, opacity:0.55 });
      const border = new THREE.Mesh(borderGeo, borderMat);
      border.rotation.x = -Math.PI / 2;
      border.position.y = 0.02;
      scene.add(border);

      // Player
      const bodyGeo = new THREE.CapsuleGeometry(PLAYER_RADIUS, PLAYER_HEIGHT - 2 * PLAYER_RADIUS, 8, 16);
      const bodyMat = new THREE.MeshStandardMaterial({ color: COLOR_PALETTE[selectedColorIndex].hex, roughness: 0.45, metalness: 0.05 });
      player = new THREE.Mesh(bodyGeo, bodyMat);
      player.position.set(0, PLAYER_HEIGHT / 2, 0);
      scene.add(player);

      const noseGeo = new THREE.SphereGeometry(0.16, 12, 12);
      const noseMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2, metalness: 0.0 });
      const nose = new THREE.Mesh(noseGeo, noseMat);
      nose.position.set(0, 0.25, PLAYER_RADIUS + 0.1);
      player.add(nose);

      playerVelocity = new THREE.Vector3(0, 0, 0);

      // Coins
      spawnCoins(COIN_SPAWN_COUNT);

      // Events
      window.addEventListener("resize", onResize);

      window.addEventListener("keydown", (e) => {
        keys.add(e.key.toLowerCase());
        if (e.key.toLowerCase() === "r" && running) resetRound();
        // Optional: press Esc to exit pointer lock (browser already does this)
      });
      window.addEventListener("keyup", (e) => keys.delete(e.key.toLowerCase()));

      // Pointer lock for smooth mouse look (click canvas to lock)
      renderer.domElement.addEventListener("click", () => {
        if (!running) return;
        renderer.domElement.requestPointerLock?.();
      });

      document.addEventListener("pointerlockchange", () => {
        pointerLocked = (document.pointerLockElement === renderer.domElement);
      });

      document.addEventListener("mousemove", (e) => {
        if (!running) return;

        // If pointer lock is available, use movementX/Y for infinite rotation.
        // If not locked, only rotate while left mouse is held down (fallback).
        if (pointerLocked) {
          camYaw   -= e.movementX * MOUSE_SENS;
          camPitch -= e.movementY * MOUSE_SENS;
        } else if (mouseDrag.active) {
          camYaw   -= (e.clientX - mouseDrag.lastX) * MOUSE_SENS;
          camPitch -= (e.clientY - mouseDrag.lastY) * MOUSE_SENS;
          mouseDrag.lastX = e.clientX;
          mouseDrag.lastY = e.clientY;
        }

        camPitch = Math.max(CAM_MIN_PITCH, Math.min(CAM_MAX_PITCH, camPitch));
      });

      // Drag fallback (when pointer lock isn't used)
      const mouseDrag = { active: false, lastX: 0, lastY: 0 };
      renderer.domElement.addEventListener("mousedown", (e) => {
        if (!running) return;
        if (e.button !== 0) return;
        mouseDrag.active = true;
        mouseDrag.lastX = e.clientX;
        mouseDrag.lastY = e.clientY;
      });
      window.addEventListener("mouseup", () => (mouseDrag.active = false));

      // Wheel zoom
      window.addEventListener("wheel", (e) => {
        if (!running) return;
        camDist += Math.sign(e.deltaY) * 0.9;
        camDist = Math.max(CAM_MIN_DIST, Math.min(CAM_MAX_DIST, camDist));
      }, { passive: true });
    }

    function onResize() {
      if (!renderer || !camera) return;
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // =========================
    // Coins + collision
    // =========================
    function randInRange(min, max) { return Math.random() * (max - min) + min; }

    function randomGroundPoint() {
      const r = Math.sqrt(Math.random()) * (WORLD_SIZE - 8);
      const a = Math.random() * Math.PI * 2;
      return { x: Math.cos(a) * r, z: Math.sin(a) * r };
    }

    function makeCoinMesh() {
      const geo = new THREE.CylinderGeometry(COIN_RADIUS, COIN_RADIUS, 0.18, 20, 1);
      const mat = new THREE.MeshStandardMaterial({
        color: 0xffd24a, roughness: 0.35, metalness: 0.45,
        emissive: 0x221400, emissiveIntensity: 0.15
      });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.rotation.z = Math.PI / 2;
      mesh.position.y = 0.7;
      return mesh;
    }

    function spawnCoins(count) {
      for (const c of coins) scene.remove(c.mesh);
      coins = [];
      for (let i = 0; i < count; i++) {
        const mesh = makeCoinMesh();
        const p = randomGroundPoint();
        mesh.position.x = p.x;
        mesh.position.z = p.z;
        scene.add(mesh);
        coins.push({ mesh, radius: COIN_RADIUS * 0.95, spin: randInRange(1.5, 3.2) });
      }
    }

    function respawnCoin(coin) {
      const p = randomGroundPoint();
      coin.mesh.position.x = p.x;
      coin.mesh.position.z = p.z;
    }

    function checkCoinCollisions() {
      const px = player.position.x, pz = player.position.z, py = player.position.y;
      const pr = PLAYER_RADIUS * 0.95;
      const playerHitY = py;

      for (const c of coins) {
        const dx = c.mesh.position.x - px;
        const dz = c.mesh.position.z - pz;
        const dy = c.mesh.position.y - playerHitY;
        const distSq = dx*dx + dy*dy + dz*dz;
        const r = pr + c.radius;

        if (distSq <= r*r) {
          coinCounter++;
          coinCountEl.textContent = String(coinCounter);
          respawnCoin(c);

          if (coinCounter >= COINS_TO_WIN) {
            winRound();
            return;
          }
        }
      }
    }

    // =========================
    // Game loop + movement
    // =========================
    function clampToWorld() {
      const r = WORLD_SIZE - 3;
      const x = player.position.x;
      const z = player.position.z;
      const d = Math.sqrt(x*x + z*z);
      if (d > r) {
        const s = r / d;
        player.position.x *= s;
        player.position.z *= s;
      }
    }

    function update(dt) {
      // Spin coins
      for (const c of coins) c.mesh.rotation.y += c.spin * dt;

      // Movement inputs
      let ax = 0, az = 0;
      if (keys.has("w") || keys.has("arrowup")) az -= 1;
      if (keys.has("s") || keys.has("arrowdown")) az += 1;
      if (keys.has("a") || keys.has("arrowleft")) ax -= 1;
      if (keys.has("d") || keys.has("arrowright")) ax += 1;

      const input = new THREE.Vector3(ax, 0, az);
      if (input.lengthSq() > 0) input.normalize();

      // Move relative to camera yaw (not full camera direction, keeps movement on ground)
      const forward = new THREE.Vector3(Math.sin(camYaw), 0, Math.cos(camYaw)).normalize(); // note: yaw uses same basis
      const right   = new THREE.Vector3(forward.z, 0, -forward.x).normalize();

      const move = new THREE.Vector3();
      move.addScaledVector(forward, input.z);
      move.addScaledVector(right, input.x);
      if (move.lengthSq() > 0) move.normalize();

      player.position.x += move.x * MOVE_SPEED * dt;
      player.position.z += move.z * MOVE_SPEED * dt;

      // Face movement direction (only if moving)
      if (move.lengthSq() > 0.0001) {
        player.rotation.y = Math.atan2(move.x, move.z);
      }

      // Gravity + jump
      playerVelocity.y += GRAVITY * dt;
      player.position.y += playerVelocity.y * dt;

      const minY = PLAYER_HEIGHT / 2;
      if (player.position.y < minY) {
        player.position.y = minY;
        playerVelocity.y = 0;
        if (keys.has(" ")) playerVelocity.y = JUMP_SPEED;
      }

      clampToWorld();

      // Apply orbit camera around player
      applyCamera();

      checkCoinCollisions();
    }

    function animate(t) {
      if (!running) return;
      const time = t * 0.001;
      const dt = Math.min(0.033, time - lastTime || 0.016);
      lastTime = time;

      update(dt);
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    // =========================
    // Round lifecycle
    // =========================
    function resetRound() {
      coinCounter = 0;
      coinCountEl.textContent = "0";
      player.position.set(0, PLAYER_HEIGHT / 2, 0);
      playerVelocity.set(0, 0, 0);
      spawnCoins(COIN_SPAWN_COUNT);

      // Reset camera to a nice default behind the player
      camYaw = Math.PI;
      camPitch = 0.45;
      camDist = 12.0;
      applyCamera();
    }

    function setPlayerColor(index) {
      selectedColorIndex = index;
      state.selectedColorIndex = index;
      saveState();
      if (player && player.material) player.material.color.setHex(COLOR_PALETTE[index].hex);
    }

    function startGame() {
      menuEl.style.display = "none";
      hudEl.style.display = "block";
      overlayMsgEl.style.display = "none";
      winSubEl.textContent = "Returning to menu…";

      if (!scene) initThree();
      setPlayerColor(selectedColorIndex);
      resetRound();

      running = true;
      lastTime = 0;
      requestAnimationFrame(animate);
    }

    function returnToMenu() {
      running = false;
      hudEl.style.display = "none";
      menuEl.style.display = "flex";
      overlayMsgEl.style.display = "none";
      renderColorPicker();

      // exit pointer lock if active
      if (document.pointerLockElement) document.exitPointerLock?.();
    }

    function winRound() {
      running = false;

      state.wins = (state.wins || 0) + 1;
      state.unlocked = Math.min(COLOR_PALETTE.length, Math.max(state.unlocked || 1, 1) + 1);
      saveState();

      overlayMsgEl.style.display = "flex";
      const unlockedIdx = Math.min(state.unlocked - 1, COLOR_PALETTE.length - 1);
      winSubEl.textContent = `Win #${state.wins} • Unlocked: ${COLOR_PALETTE[unlockedIdx].name}`;

      if (document.pointerLockElement) document.exitPointerLock?.();

      setTimeout(() => returnToMenu(), 1800);
    }

    // =========================
    // Menu button
    // =========================
    startBtn.addEventListener("click", () => startGame());

    // Fix corrupted state
    if (selectedColorIndex >= state.unlocked) {
      selectedColorIndex = 0;
      state.selectedColorIndex = 0;
      saveState();
    }
  </script>
</body>
</html>
