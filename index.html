<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mini 3D Coin Game</title>
  <style>
    html, body { margin:0; padding:0; overflow:hidden; background:#0b1020; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #hud {
      position: fixed; left: 12px; top: 12px; color: white;
      padding: 10px 12px; border-radius: 12px;
      background: rgba(0,0,0,0.35); backdrop-filter: blur(6px);
      user-select: none; pointer-events: none;
      font-weight: 700;
    }
    #hud small { display:block; opacity:.75; font-weight:600; margin-top:4px; }
    #menu {
      position: fixed; inset: 0; display: flex; align-items: center; justify-content: center;
      background: radial-gradient(circle at 50% 40%, rgba(40,140,255,.22), rgba(0,0,0,.85) 65%);
      color: white;
    }
    .panel {
      width: min(720px, 92vw);
      background: rgba(0,0,0,0.45);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 18px;
      padding: 18px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    }
    h1 { margin: 0 0 10px; font-size: 28px; letter-spacing: .2px; }
    p { margin: 8px 0; opacity: .9; line-height: 1.35; }
    .row { display:flex; gap:12px; flex-wrap: wrap; margin-top: 14px; }
    .swatch {
      width: 58px; height: 58px; border-radius: 14px; border: 2px solid rgba(255,255,255,0.16);
      display:flex; align-items:center; justify-content:center;
      cursor: pointer;
      position: relative;
      box-shadow: inset 0 0 0 2px rgba(0,0,0,0.25);
    }
    .swatch:hover { transform: translateY(-1px); }
    .swatch.locked { opacity: .35; cursor: not-allowed; filter: grayscale(35%); }
    .swatch.selected { outline: 3px solid rgba(255,255,255,0.75); outline-offset: 3px; }
    .badge {
      position:absolute; bottom:-8px; right:-8px;
      background: rgba(0,0,0,0.65);
      border: 1px solid rgba(255,255,255,0.16);
      color: white; font-size: 11px; padding: 2px 6px; border-radius: 999px;
    }
    button {
      margin-top: 14px;
      appearance: none; border: 0; cursor: pointer;
      padding: 12px 16px; border-radius: 14px;
      background: rgba(255,255,255,0.92);
      color:#101424; font-weight: 900;
    }
    button:active { transform: translateY(1px); }
    #overlayMsg {
      position: fixed; inset: 0; display:none; align-items:center; justify-content:center;
      background: rgba(0,0,0,0.35);
      color:white; font-size: 56px; font-weight: 1000; letter-spacing: 1px;
      text-shadow: 0 10px 30px rgba(0,0,0,0.7);
      user-select:none;
    }
    #overlayMsg .sub { font-size: 16px; font-weight: 700; opacity: .85; margin-top: 12px; text-align:center; }
    #overlayMsg .wrap { display:flex; flex-direction: column; align-items:center; }
    canvas { display:block; }
  </style>
</head>
<body>
  <div id="hud" style="display:none">
    Coins: <span id="coinCount">0</span> / 100
    <small>WASD / Arrow keys to move • Space to jump • R to reset</small>
  </div>

  <div id="menu">
    <div class="panel">
      <h1>Mini 3D Coin Game</h1>
      <p>Pick your character color. Collect 100 coins to win. Each win unlocks a new color.</p>
      <p><b>Controls:</b> WASD or Arrow Keys move, Space jumps, R resets the round.</p>
      <div class="row" id="colorRow"></div>
      <button id="startBtn">Start Game</button>
      <p style="margin-top:10px; opacity:.75">
        Tip: If your browser complains about “file://” security, run a tiny local server
        (VS Code “Live Server” extension works great).
      </p>
    </div>
  </div>

  <div id="overlayMsg">
    <div class="wrap">
      <div id="winText">You Win!</div>
      <div class="sub" id="winSub">Returning to menu…</div>
    </div>
  </div>

  <!-- Three.js (UMD global) -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

  <script>
    // =========================
    // Persistent unlock system
    // =========================
    const STORAGE_KEY = "mini3d_coin_game_v1";
    const DEFAULT_STATE = {
      wins: 0,
      unlocked: 1, // number of colors unlocked (starting at 1)
      selectedColorIndex: 0
    };

    const COLOR_PALETTE = [
      { name: "Red",    hex: 0xe74c3c },
      { name: "Green",  hex: 0x2ecc71 },
      { name: "Blue",   hex: 0x3498db },
      { name: "Yellow", hex: 0xf1c40f },
      { name: "Purple", hex: 0x9b59b6 },
      { name: "Orange", hex: 0xe67e22 },
      { name: "Cyan",   hex: 0x1abc9c },
      { name: "Pink",   hex: 0xff5ca8 },
      { name: "White",  hex: 0xf5f7ff },
      { name: "Black",  hex: 0x111318 },
    ];

    function loadState() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return { ...DEFAULT_STATE };
        const parsed = JSON.parse(raw);
        return { ...DEFAULT_STATE, ...parsed };
      } catch {
        return { ...DEFAULT_STATE };
      }
    }

    function saveState() {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    }

    let state = loadState();

    // =========================
    // UI (menu + unlocks)
    // =========================
    const menuEl = document.getElementById("menu");
    const colorRowEl = document.getElementById("colorRow");
    const startBtn = document.getElementById("startBtn");
    const hudEl = document.getElementById("hud");
    const coinCountEl = document.getElementById("coinCount");
    const overlayMsgEl = document.getElementById("overlayMsg");
    const winSubEl = document.getElementById("winSub");

    let selectedColorIndex = Math.min(state.selectedColorIndex, COLOR_PALETTE.length - 1);

    function renderColorPicker() {
      colorRowEl.innerHTML = "";
      const unlockedCount = Math.min(state.unlocked, COLOR_PALETTE.length);

      COLOR_PALETTE.forEach((c, idx) => {
        const div = document.createElement("div");
        div.className = "swatch" + (idx >= unlockedCount ? " locked" : "") + (idx === selectedColorIndex ? " selected" : "");
        div.style.background = `#${c.hex.toString(16).padStart(6, "0")}`;
        div.title = (idx < unlockedCount) ? c.name : `${c.name} (locked)`;

        if (idx >= unlockedCount) {
          const badge = document.createElement("div");
          badge.className = "badge";
          badge.textContent = "LOCKED";
          div.appendChild(badge);
        } else {
          const badge = document.createElement("div");
          badge.className = "badge";
          badge.textContent = c.name;
          div.appendChild(badge);

          div.addEventListener("click", () => {
            selectedColorIndex = idx;
            state.selectedColorIndex = idx;
            saveState();
            renderColorPicker();
          });
        }

        colorRowEl.appendChild(div);
      });

      startBtn.textContent = `Start Game (Wins: ${state.wins})`;
    }

    renderColorPicker();

    // =========================
    // Three.js game setup
    // =========================
    let scene, camera, renderer;
    let player, playerVelocity;
    let ground;
    let coins = [];
    let coinCounter = 0;
    const COINS_TO_WIN = 100;

    // World settings
    const WORLD_SIZE = 180;      // plane extends about this radius
    const COIN_SPAWN_COUNT = 40; // coins present at a time (they respawn after pickup)
    const COIN_RADIUS = 0.55;
    const PLAYER_RADIUS = 0.7;
    const PLAYER_HEIGHT = 1.6;

    // Movement
    const keys = new Set();
    const GRAVITY = -28;
    const MOVE_SPEED = 10;
    const JUMP_SPEED = 11.5;

    let running = false;
    let lastTime = 0;

    function initThree() {
      scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x0b1020, 35, 220);

      camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 500);
      camera.position.set(0, 7, 12);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      // Lights
      const hemi = new THREE.HemisphereLight(0xffffff, 0x223355, 0.8);
      scene.add(hemi);

      const dir = new THREE.DirectionalLight(0xffffff, 1.0);
      dir.position.set(12, 18, 8);
      dir.castShadow = false;
      scene.add(dir);

      // Ground
      const groundGeo = new THREE.PlaneGeometry(WORLD_SIZE * 2, WORLD_SIZE * 2, 1, 1);
      const groundMat = new THREE.MeshStandardMaterial({ color: 0x1e2a44, roughness: 1.0, metalness: 0.0 });
      ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = 0;
      scene.add(ground);

      // A little border vibe (not collision, just visual)
      const borderGeo = new THREE.RingGeometry(WORLD_SIZE - 1, WORLD_SIZE + 1, 64);
      const borderMat = new THREE.MeshBasicMaterial({ color: 0x223a66, side: THREE.DoubleSide, transparent:true, opacity:0.55 });
      const border = new THREE.Mesh(borderGeo, borderMat);
      border.rotation.x = -Math.PI / 2;
      border.position.y = 0.02;
      scene.add(border);

      // Player
      const bodyGeo = new THREE.CapsuleGeometry(PLAYER_RADIUS, PLAYER_HEIGHT - 2 * PLAYER_RADIUS, 8, 16);
      const bodyMat = new THREE.MeshStandardMaterial({ color: COLOR_PALETTE[selectedColorIndex].hex, roughness: 0.45, metalness: 0.05 });
      player = new THREE.Mesh(bodyGeo, bodyMat);
      player.position.set(0, PLAYER_HEIGHT / 2, 0);
      scene.add(player);

      // Player "face" dot for direction (purely for fun)
      const noseGeo = new THREE.SphereGeometry(0.16, 12, 12);
      const noseMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2, metalness: 0.0 });
      const nose = new THREE.Mesh(noseGeo, noseMat);
      nose.position.set(0, 0.25, PLAYER_RADIUS + 0.1);
      player.add(nose);

      playerVelocity = new THREE.Vector3(0, 0, 0);

      // Coins
      spawnCoins(COIN_SPAWN_COUNT);

      // Events
      window.addEventListener("resize", onResize);
      window.addEventListener("keydown", (e) => {
        keys.add(e.key.toLowerCase());
        if (e.key.toLowerCase() === "r" && running) resetRound();
      });
      window.addEventListener("keyup", (e) => keys.delete(e.key.toLowerCase()));
    }

    function onResize() {
      if (!renderer || !camera) return;
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // =========================
    // Coins + collision
    // =========================
    function randInRange(min, max) {
      return Math.random() * (max - min) + min;
    }

    function randomGroundPoint() {
      // Keep it inside a circle, not near the very edge
      const r = Math.sqrt(Math.random()) * (WORLD_SIZE - 8);
      const a = Math.random() * Math.PI * 2;
      return { x: Math.cos(a) * r, z: Math.sin(a) * r };
    }

    function makeCoinMesh() {
      // Mario-ish coin: thin cylinder
      const geo = new THREE.CylinderGeometry(COIN_RADIUS, COIN_RADIUS, 0.18, 20, 1);
      const mat = new THREE.MeshStandardMaterial({ color: 0xffd24a, roughness: 0.35, metalness: 0.45, emissive: 0x221400, emissiveIntensity: 0.15 });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.rotation.z = Math.PI / 2; // stand it up
      mesh.position.y = 0.7;         // sit on floor visually
      return mesh;
    }

    function spawnCoins(count) {
      // Clear old
      for (const c of coins) scene.remove(c.mesh);
      coins = [];

      for (let i = 0; i < count; i++) {
        const mesh = makeCoinMesh();
        const p = randomGroundPoint();
        mesh.position.x = p.x;
        mesh.position.z = p.z;
        scene.add(mesh);

        coins.push({
          mesh,
          // Simple hitbox: sphere
          radius: COIN_RADIUS * 0.95,
          spin: randInRange(1.5, 3.2)
        });
      }
    }

    function respawnCoin(coin) {
      const p = randomGroundPoint();
      coin.mesh.position.x = p.x;
      coin.mesh.position.z = p.z;
    }

    function checkCoinCollisions() {
      // Treat player as a vertical capsule-ish; for simplicity use a sphere at player center.
      const px = player.position.x;
      const pz = player.position.z;
      const py = player.position.y;

      // Use a sphere centered around torso
      const playerHitY = py; // close enough
      const pr = PLAYER_RADIUS * 0.95;

      for (const c of coins) {
        const dx = c.mesh.position.x - px;
        const dz = c.mesh.position.z - pz;
        const dy = c.mesh.position.y - playerHitY;

        const distSq = dx*dx + dy*dy + dz*dz;
        const r = pr + c.radius;

        if (distSq <= r*r) {
          coinCounter++;
          coinCountEl.textContent = String(coinCounter);
          // Respawn this coin somewhere else
          respawnCoin(c);

          if (coinCounter >= COINS_TO_WIN) {
            winRound();
            return;
          }
        }
      }
    }

    // =========================
    // Game loop + movement
    // =========================
    function clampToWorld() {
      const r = WORLD_SIZE - 3;
      const x = player.position.x;
      const z = player.position.z;
      const d = Math.sqrt(x*x + z*z);
      if (d > r) {
        const s = r / d;
        player.position.x *= s;
        player.position.z *= s;
      }
    }

    function update(dt) {
      // Spin coins
      for (const c of coins) {
        c.mesh.rotation.y += c.spin * dt;
      }

      // Movement inputs
      let ax = 0, az = 0;
      if (keys.has("w") || keys.has("arrowup")) az -= 1;
      if (keys.has("s") || keys.has("arrowdown")) az += 1;
      if (keys.has("a") || keys.has("arrowleft")) ax -= 1;
      if (keys.has("d") || keys.has("arrowright")) ax += 1;

      const dir = new THREE.Vector3(ax, 0, az);
      if (dir.lengthSq() > 0) dir.normalize();

      // Camera-relative movement (forward = where camera looks)
      const camForward = new THREE.Vector3();
      camera.getWorldDirection(camForward);
      camForward.y = 0;
      camForward.normalize();

      const camRight = new THREE.Vector3().crossVectors(camForward, new THREE.Vector3(0,1,0)).normalize().multiplyScalar(-1);

      const move = new THREE.Vector3();
      move.addScaledVector(camForward, dir.z);
      move.addScaledVector(camRight, dir.x);
      if (move.lengthSq() > 0) move.normalize();

      player.position.x += move.x * MOVE_SPEED * dt;
      player.position.z += move.z * MOVE_SPEED * dt;

      // Face direction of movement
      if (move.lengthSq() > 0.0001) {
        const targetYaw = Math.atan2(move.x, move.z);
        player.rotation.y = targetYaw;
      }

      // Gravity + jump
      playerVelocity.y += GRAVITY * dt;
      player.position.y += playerVelocity.y * dt;

      // Ground collision (y=0)
      const minY = PLAYER_HEIGHT / 2;
      if (player.position.y < minY) {
        player.position.y = minY;
        playerVelocity.y = 0;

        // Jump only if grounded
        if (keys.has(" ")) {
          playerVelocity.y = JUMP_SPEED;
        }
      }

      clampToWorld();

      // Third-person camera follow
      const behindDistance = 10.5;
      const height = 6.0;
      const lookAtHeight = 1.2;

      const yaw = player.rotation.y;
      const behind = new THREE.Vector3(
        Math.sin(yaw) * behindDistance,
        height,
        Math.cos(yaw) * behindDistance
      );

      const desiredCamPos = new THREE.Vector3().copy(player.position).add(behind);
      camera.position.lerp(desiredCamPos, 1 - Math.pow(0.001, dt)); // smooth
      camera.lookAt(player.position.x, player.position.y + lookAtHeight, player.position.z);

      checkCoinCollisions();
    }

    function animate(t) {
      if (!running) return;
      const time = t * 0.001;
      const dt = Math.min(0.033, time - lastTime || 0.016);
      lastTime = time;

      update(dt);
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    // =========================
    // Round lifecycle
    // =========================
    function resetRound() {
      coinCounter = 0;
      coinCountEl.textContent = "0";
      player.position.set(0, PLAYER_HEIGHT / 2, 0);
      playerVelocity.set(0, 0, 0);
      spawnCoins(COIN_SPAWN_COUNT);
    }

    function setPlayerColor(index) {
      selectedColorIndex = index;
      state.selectedColorIndex = index;
      saveState();
      if (player && player.material) player.material.color.setHex(COLOR_PALETTE[index].hex);
    }

    function startGame() {
      menuEl.style.display = "none";
      hudEl.style.display = "block";
      overlayMsgEl.style.display = "none";
      winSubEl.textContent = "Returning to menu…";

      if (!scene) initThree();
      setPlayerColor(selectedColorIndex);
      resetRound();

      running = true;
      lastTime = 0;
      requestAnimationFrame(animate);
    }

    function returnToMenu() {
      running = false;
      hudEl.style.display = "none";
      menuEl.style.display = "flex";
      overlayMsgEl.style.display = "none";
      renderColorPicker();
    }

    function winRound() {
      running = false;

      // Unlock logic: each win unlocks the next color (up to palette length)
      state.wins = (state.wins || 0) + 1;
      state.unlocked = Math.min(COLOR_PALETTE.length, Math.max(state.unlocked || 1, 1) + 1);
      saveState();

      overlayMsgEl.style.display = "flex";
      winSubEl.textContent = `Win #${state.wins} • Unlocked: ${COLOR_PALETTE[Math.min(state.unlocked-1, COLOR_PALETTE.length-1)].name}`;

      // Small pause, then back to menu
      setTimeout(() => {
        returnToMenu();
      }, 1800);
    }

    // =========================
    // Menu button
    // =========================
    startBtn.addEventListener("click", () => {
      startGame();
    });

    // If state selected is locked due to corruption, fix it
    if (selectedColorIndex >= state.unlocked) {
      selectedColorIndex = 0;
      state.selectedColorIndex = 0;
      saveState();
    }
  </script>
</body>
</html>
